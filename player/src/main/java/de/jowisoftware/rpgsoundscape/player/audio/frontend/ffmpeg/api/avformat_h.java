// Generated by jextract

package de.jowisoftware.rpgsoundscape.player.audio.frontend.ffmpeg.api;

import jdk.incubator.foreign.Addressable;
import jdk.incubator.foreign.CLinker;
import jdk.incubator.foreign.MemoryAddress;
import jdk.incubator.foreign.MemoryHandles;
import jdk.incubator.foreign.MemoryLayout;
import jdk.incubator.foreign.MemoryLayout.PathElement;
import jdk.incubator.foreign.MemorySegment;

import static de.jowisoftware.rpgsoundscape.player.audio.frontend.ffmpeg.api.avformat_h_constants.AVStream$struct$LAYOUT_;

public final class avformat_h {
    public static final int EAGAIN = (int) -11L;
    public static final int AVERROR_EOF = (int) -541478725L;
    public static final int AV_CH_LAYOUT_STEREO = (int) 3L;

    public static void av_packet_unref(Addressable pkt) {
        try {
            avformat_h_constants.av_packet_unref$MH_.invokeExact(pkt.address());
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static void avcodec_free_context(Addressable avctx) {
        try {
            avformat_h_constants.avcodec_free_context$MH_.invokeExact(avctx.address());
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static int avformat_open_input(Addressable ps, Addressable url, Addressable fmt, Addressable options) {
        try {
            return (int) avformat_h_constants.avformat_open_input$MH().invokeExact(
                    ps.address(), url.address(), fmt.address(), options.address());
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static int avformat_find_stream_info(Addressable ic, Addressable options) {
        try {
            return (int) avformat_h_constants.avformat_find_stream_info$MH().invokeExact(ic.address(), options.address());
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static int av_find_best_stream(Addressable ic, int type, int wanted_stream_nb, int related_stream, Addressable decoder_ret, int flags) {
        try {
            return (int) avformat_h_constants.av_find_best_stream$MH().invokeExact(ic.address(), type, wanted_stream_nb, related_stream, decoder_ret.address(), flags);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static int av_read_frame(Addressable s, Addressable pkt) {
        try {
            return (int) avformat_h_constants.av_read_frame$MH().invokeExact(s.address(), pkt.address());
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static void avformat_close_input(Addressable s) {
        try {
            avformat_h_constants.avformat_close_input$MH_.invokeExact(s.address());
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static int AV_SAMPLE_FMT_S16() {
        return avformat_h_constants.AV_SAMPLE_FMT_S16();
    }

    public static long av_get_default_channel_layout(int nb_channels) {
        try {
            return (long) avformat_h_constants.av_get_default_channel_layout$MH_.invokeExact(nb_channels);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static MemoryAddress av_frame_alloc() {
        try {
            return (MemoryAddress) avformat_h_constants.av_frame_alloc$MH_.invokeExact();
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    public static int AVMEDIA_TYPE_AUDIO() {
        return avformat_h_constants.AVMEDIA_TYPE_AUDIO();
    }

    public static class AVFrame {
        public static MemoryLayout layout() {
            return avformat_h_constants.AVFrame$struct$LAYOUT_;
        }
    }

    public static class AVPacket {
        public static MemoryLayout layout() {
            return avformat_h_constants.AVPacket$struct$LAYOUT_;
        }

        public static void data$set(MemorySegment seg, MemoryAddress x) {
            avformat_h_constants.AVPacket$data$VH_.set(seg, x);
        }

        public static void size$set(MemorySegment seg, int x) {
            avformat_h_constants.AVPacket$size$VH_.set(seg, x);
        }

        public static int stream_index$get(MemorySegment seg) {
            return (int) avformat_h_constants.AVPacket$stream_index$VH_.get(seg);
        }
    }

    public static class AVCodec {
        public static MemoryLayout layout() {
            return avformat_h_constants.AVCodec$struct$LAYOUT_;
        }
    }

    public static class AVCodecContext {
        public static MemoryLayout layout() {
            return avformat_h_constants.AVCodecContext$struct$LAYOUT_;
        }

        public static int sample_rate$get(MemorySegment seg) {
            return (int) avformat_h_constants.AVCodecContext$sample_rate$VH_.get(seg);
        }

        public static int channels$get(MemorySegment seg) {
            return (int) avformat_h_constants.AVCodecContext$channels$VH_.get(seg);
        }

        public static int sample_fmt$get(MemorySegment seg) {
            return (int) avformat_h_constants.AVCodecContext$sample_fmt$VH_.get(seg);
        }

        public static long channel_layout$get(MemorySegment seg) {
            return (long) avformat_h_constants.AVCodecContext$channel_layout$VH_.get(seg);
        }

        public static void channel_layout$set(MemorySegment seg, long x) {
            avformat_h_constants.AVCodecContext$channel_layout$VH_.set(seg, x);
        }

        public static MemorySegment pkt_timebase$slice(MemorySegment seg) {
            return RuntimeHelper.nonCloseableNonTransferableSegment(seg.asSlice(884, 8));
        }

    }

    public static class AVStream {
        public static MemoryLayout layout() {
            return AVStream$struct$LAYOUT_;
        }

        public static MemoryAddress codecpar$get(MemorySegment seg) {
            return (MemoryAddress) avformat_h_constants.AVStream$codecpar$VH_.get(seg);
        }

        public static MemorySegment timeBase$slice(MemorySegment segment) {
            return RuntimeHelper.nonCloseableNonTransferableSegment(
                    segment.asSlice(avformat_h_constants.AVStream$struct$timeBase$offset,
                            avformat_h_constants.AVStream$struct$timeBase$size));
        }
    }

    public static class AVFormatContext {
        public static MemoryLayout layout() {
            return avformat_h_constants.AVFormatContext$struct$LAYOUT_;
        }

        public static MemoryAddress streams$get(MemorySegment seg, long index) {
            MemorySegment streamsPointerArray = ((MemoryAddress) MemoryHandles.asAddressVarHandle(AVFormatContext.layout()
                    .varHandle(long.class, PathElement.groupElement("streams")))
                    .get(seg))
                    .asSegmentRestricted(CLinker.C_POINTER.byteSize() * (index + 1));

            return (MemoryAddress) MemoryHandles.asAddressVarHandle(
                    MemoryLayout.ofSequence(CLinker.C_POINTER)
                            .varHandle(long.class, PathElement.sequenceElement(index)))
                    .get(streamsPointerArray);
        }

    }
}


